---
phase: 01-mvp-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: []
autonomous: true
requirements: [ARCH-01, ARCH-04, ARCH-05, ARCH-08]

must_haves:
  truths:
    - "FastAPI application starts and responds to requests"
    - "Request logs contain no filenames, IPs, file sizes, or user data"
    - "All responses include privacy-preserving cache headers"
    - "Cleanup handlers run on all exit paths"
  artifacts:
    - path: "app/main.py"
      provides: "FastAPI application entry point"
      exports: ["app"]
    - path: "app/middleware/privacy_logging.py"
      provides: "Privacy-aware logging middleware"
      contains: "PrivacyLoggingMiddleware"
    - path: "app/middleware/cache_headers.py"
      provides: "Cache control headers middleware"
      contains: "Cache-Control: no-store"
    - path: "app/core/config.py"
      provides: "Application configuration"
      exports: ["Settings"]
  key_links:
    - from: "app/main.py"
      to: "app/middleware/privacy_logging.py"
      via: "middleware registration"
      pattern: "app.add_middleware.*Privacy"
---

<objective>
Establish the foundational FastAPI application with privacy-first architecture ensuring all user data is protected from logging and caching.

Purpose: Build the secure foundation that all PDF processing will run on top of. Zero-trace must be architected from the start, not added later.

Output: Working FastAPI application with privacy middleware, configuration, and cleanup handlers.
</objective>

<execution_context>
@/home/ubuntu/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/STACK.md
@.planning/research/PITFALLS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FastAPI project structure with configuration</name>
  <files>
    app/__init__.py
    app/main.py
    app/core/__init__.py
    app/core/config.py
    requirements.txt
    .env.example
  </files>
  <action>
    Create FastAPI project structure following Python best practices:

    1. Create `app/main.py` with FastAPI app instance, CORS middleware (allow all origins for self-hosted), and health endpoint at GET /health returning {"status": "ok"}

    2. Create `app/core/config.py` using Pydantic Settings:
       - Settings class with: APP_NAME (default: "NoTracePDF"), DEBUG (default: False), MAX_FILE_SIZE_MB (default: 100), UPLOAD_DIR (default: "/tmp/uploads")
       - Load from environment variables

    3. Create `requirements.txt` with versions:
       - fastapi==0.129.0
       - uvicorn[standard]==0.34.0
       - python-multipart==0.0.20
       - pydantic==2.10.0
       - python-dotenv==1.0.0

    4. Create `.env.example` with example configuration values

    Do NOT include any PDF processing libraries yet - those come in later plans.
    Do NOT add logging configuration yet - that's Task 2.
  </action>
  <verify>
    python -c "from app.main import app; print('OK')" && python -c "from app.core.config import Settings; s = Settings(); print(f'Config OK: {s.APP_NAME}')"
  </verify>
  <done>
    - FastAPI app imports without errors
    - Settings class loads configuration from environment
    - requirements.txt lists core dependencies with versions
    - .env.example documents available configuration options
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement privacy-aware logging middleware</name>
  <files>
    app/middleware/__init__.py
    app/middleware/privacy_logging.py
  </files>
  <action>
    Create privacy-aware logging middleware that sanitizes all request data:

    1. Create `app/middleware/privacy_logging.py`:
       - PrivacyLoggingMiddleware class using Starlette middleware pattern
       - Logs ONLY: timestamp, method, path, response_status, processing_time_ms
       - NEVER logs: request body, query params with file data, IP addresses, filenames, file sizes
       - Use structlog or standard logging with explicit field selection

    2. Configure logging in the middleware to:
       - Set level INFO for production
       - Format: JSON structured logs preferred
       - Include request_id for traceability without user data

    3. Register middleware in `app/main.py`:
       - Add PrivacyLoggingMiddleware before other middleware

    Critical: Any request containing file uploads MUST NOT have filename, size, or content logged even on error.

    Reference PITFALLS.md "Logging User Data" section - this is a critical security requirement.
  </action>
  <verify>
    python -c "
from app.middleware.privacy_logging import PrivacyLoggingMiddleware
import logging
import io
# Verify middleware can be instantiated
print('PrivacyLoggingMiddleware class exists')
" && grep -q "PrivacyLoggingMiddleware" app/main.py
  </verify>
  <done>
    - PrivacyLoggingMiddleware class exists and is registered
    - Middleware logs method and path only (no IP, no body, no filenames)
    - Logs use structured format
    - Middleware is applied to all requests
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement cache control headers middleware</name>
  <files>
    app/middleware/cache_headers.py
    app/main.py
  </files>
  <action>
    Create middleware that enforces privacy-preserving cache headers on all responses:

    1. Create `app/middleware/cache_headers.py`:
       - CacheHeadersMiddleware class using Starlette middleware pattern
       - Adds to ALL responses:
         - Cache-Control: no-store, no-cache, must-revalidate, private
         - Pragma: no-cache
         - Expires: 0
         - X-Content-Type-Options: nosniff

    2. Register middleware in `app/main.py`:
       - Add CacheHeadersMiddleware after privacy logging

    3. Create a test endpoint GET /test-cache that returns a simple JSON response

    4. Verify headers are applied using curl

    Reference ARCH-05: This is a requirement. Reference PITFALLS.md "Browser Caching of Sensitive Downloads" - prevents browser from storing user files.
  </action>
  <verify>
    python -c "from app.middleware.cache_headers import CacheHeadersMiddleware; print('OK')" && curl -s -I http://localhost:8000/test-cache 2>/dev/null | grep -i "cache-control" | grep -q "no-store" || echo "Server not running - middleware code exists"
  </verify>
  <done>
    - CacheHeadersMiddleware class exists and is registered
    - All responses include Cache-Control: no-store, no-cache, must-revalidate, private
    - All responses include Pragma: no-cache, Expires: 0, X-Content-Type-Options: nosniff
    - Headers verified via curl test
  </done>
</task>

<task type="auto">
  <name>Task 4: Implement cleanup handlers for all exit paths</name>
  <files>
    app/core/cleanup.py
    app/main.py
  </files>
  <action>
    Create cleanup handlers that ensure resources are released on all exit paths:

    1. Create `app/core/cleanup.py`:
       - cleanup_temp_files() function that removes any temporary files
       - register_cleanup_handlers() function that registers signal handlers
       - Handle: SIGTERM, SIGINT (graceful shutdown)
       - Use try/finally patterns for request-level cleanup

    2. Register handlers in `app/main.py`:
       - Call register_cleanup_handlers() on startup
       - Use FastAPI on_event("startup") for initialization

    3. Create a global temporary file tracker:
       - In-memory set to track active processing sessions
       - Cleanup function iterates and removes any tracked temp files

    Note: Currently no temp files are created (in-memory only), but this establishes the pattern for future operations that might need tmpfs cleanup.

    Reference ARCH-08: Cleanup handlers must run on success, error, and SIGTERM.
  </action>
  <verify>
    python -c "
from app.core.cleanup import cleanup_temp_files, register_cleanup_handlers
print('Cleanup functions exist')
" && grep -q "register_cleanup_handlers" app/main.py
  </verify>
  <done>
    - cleanup_temp_files() function exists
    - register_cleanup_handlers() function exists and registers SIGTERM/SIGINT handlers
    - Handlers are registered on app startup
    - Pattern established for tracking and cleaning temporary resources
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Start server: `uvicorn app.main:app --host 0.0.0.0 --port 8000`
2. Test health endpoint: `curl http://localhost:8000/health`
3. Verify cache headers: `curl -I http://localhost:8000/health | grep -i cache`
4. Verify logs don't contain sensitive data by making requests and checking output
5. Test signal handling: send SIGTERM and verify clean shutdown
</verification>

<success_criteria>
- FastAPI application starts successfully
- Privacy logging middleware sanitizes all request data
- Cache headers prevent browser caching on all responses
- Cleanup handlers registered for graceful shutdown
- No user data can appear in logs
- Requirements ARCH-01, ARCH-04, ARCH-05, ARCH-08 are implemented
</success_criteria>

<output>
After completion, create `.planning/phases/01-mvp-foundation/01-01-SUMMARY.md`
</output>
