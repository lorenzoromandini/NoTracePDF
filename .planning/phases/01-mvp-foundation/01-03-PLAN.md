---
phase: 01-mvp-foundation
plan: 03
type: execute
wave: 2
depends_on: [01-01, 01-02]
files_modified: []
autonomous: true
requirements: [PDF-01, PDF-02, PDF-03, PDF-04, PDF-05, PDF-06, PDF-07]

must_haves:
  truths:
    - "User can merge multiple PDFs into single document"
    - "User can split PDF by page range (e.g., pages 1-5)"
    - "User can split PDF every N pages"
    - "User can extract specific pages from PDF"
    - "User can rotate single pages or all pages"
    - "User can reorder pages via page list input"
    - "User can delete pages from PDF"
  artifacts:
    - path: "app/services/pdf_service.py"
      provides: "PDF core operations module"
      exports: ["merge_pdfs", "split_pdf", "rotate_pages", "reorder_pages", "delete_pages"]
    - path: "app/api/v1/pdf.py"
      provides: "PDF API endpoints"
      exports: ["router"]
    - path: "app/schemas/pdf.py"
      provides: "PDF operation request/response schemas"
      exports: ["MergeRequest", "SplitRequest", "RotateRequest"]
  key_links:
    - from: "app/api/v1/pdf.py"
      to: "app/services/pdf_service.py"
      via: "service import"
      pattern: "from app.services.pdf_service import"
    - from: "app/services/pdf_service.py"
      to: "pikepdf"
      via: "PDF manipulation library"
      pattern: "import pikepdf"
---

<objective>
Implement core PDF manipulation operations (merge, split, rotate, reorder, delete) using pikepdf with in-memory processing.

Purpose: These are the most common PDF operations users expect. Implementation must use BytesIO for all operations to maintain zero-trace guarantee.

Output: Working PDF core operations module with REST API endpoints, all processing in-memory.
</objective>

<execution_context>
@/home/ubuntu/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/STACK.md
@.planning/research/PITFALLS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add pikepdf dependency and create PDF service module</name>
  <files>
    requirements.txt
    app/services/__init__.py
    app/services/pdf_service.py
    app/schemas/__init__.py
    app/schemas/pdf.py
  </files>
  <action>
    Set up PDF processing infrastructure with pikepdf:

    1. Update `requirements.txt`:
       - pikepdf==10.4.0

    2. Create `app/schemas/pdf.py`:
       - PageRangeInput: start (int), end (int)
       - SplitRequest: mode (enum: range, every_n, specific), page_range (optional), n_pages (optional), pages (list[int], optional)
       - RotateRequest: pages (list[int] or "all"), degrees (90, 180, 270)
       - ReorderRequest: page_order (list[int])
       - DeleteRequest: pages (list[int])

    3. Create `app/services/pdf_service.py`:
       - merge_pdfs(files: list[BytesIO]) -> BytesIO
         - Accept list of PDF BytesIO objects
         - Use pikepdf.Pdf.new() and extend pages
         - Return merged PDF as BytesIO
       - split_pdf(file: BytesIO, mode, params) -> list[BytesIO]
         - Support three modes: range, every_n, specific_pages
         - Return list of BytesIO objects
       - All functions work entirely in memory (BytesIO in/out)

    Key: NO file paths. NO disk writes. Everything uses BytesIO streams.

    Reference STACK.md "In-Memory Processing Patterns" for pikepdf BytesIO usage.
    Reference ARCH-01: All file processing uses in-memory streams.
  </action>
  <verify>
    pip install pikepdf==10.4.0 -q && python -c "
from app.services.pdf_service import merge_pdfs, split_pdf
from app.schemas.pdf import SplitRequest, RotateRequest
print('PDF service imports OK')
"
  </verify>
  <done>
    - pikepdf added to requirements.txt
    - PDF schemas defined for all request types
    - merge_pdfs function works with BytesIO
    - split_pdf function supports all three modes
    - All operations are in-memory only
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement rotate, reorder, and delete operations</name>
  <files>
    app/services/pdf_service.py
    app/schemas/pdf.py
  </files>
  <action>
    Complete PDF manipulation operations:

    1. Add to `app/services/pdf_service.py`:
       - rotate_pages(file: BytesIO, pages, degrees) -> BytesIO
         - Accept "all" or list of page numbers (1-indexed)
         - Rotate specified pages by degrees (90, 180, 270)
         - Return modified PDF as BytesIO
       - reorder_pages(file: BytesIO, page_order: list[int]) -> BytesIO
         - Accept new page order as list (e.g., [3, 1, 2, 4])
         - Reorder pages accordingly
         - Return modified PDF as BytesIO
       - delete_pages(file: BytesIO, pages: list[int]) -> BytesIO
         - Accept list of page numbers to delete (1-indexed)
         - Remove specified pages
         - Return modified PDF as BytesIO

    2. Add validation to schemas:
       - Validate page numbers are within range
       - Validate degrees is one of [90, 180, 270]
       - Validate page_order contains valid pages

    3. Add error handling:
       - InvalidPageError for out-of-range pages
       - InvalidRotationError for invalid degrees
       - EmptyResultError if all pages deleted

    All functions use pikepdf with BytesIO streams. NO disk writes.
  </action>
  <verify>
    python -c "
from app.services.pdf_service import rotate_pages, reorder_pages, delete_pages
print('Rotate, reorder, delete functions exist')
"
  </verify>
  <done>
    - rotate_pages handles single pages, multiple pages, or all pages
    - reorder_pages accepts new page order list
    - delete_pages removes specified pages
    - All operations work in-memory
    - Error handling for invalid inputs
  </done>
</task>

<task type="auto">
  <name>Task 3: Create REST API endpoints for PDF core operations</name>
  <files>
    app/api/__init__.py
    app/api/v1/__init__.py
    app/api/v1/pdf.py
    app/main.py
  </files>
  <action>
    Create FastAPI endpoints for PDF core operations:

    1. Create `app/api/v1/pdf.py`:
       - POST /api/v1/pdf/merge
         - Accept multiple files via UploadFile
         - Return merged PDF with download filename
         - Cache-Control headers already applied by middleware
       - POST /api/v1/pdf/split
         - Accept single file + split parameters (mode, range, n, pages)
         - Return ZIP of split PDFs (or single PDF if one result)
       - POST /api/v1/pdf/rotate
         - Accept file + rotation parameters
         - Return rotated PDF
       - POST /api/v1/pdf/reorder
         - Accept file + page order
         - Return reordered PDF
       - POST /api/v1/pdf/delete-pages
         - Accept file + pages to delete
         - Return modified PDF

    2. Create `app/api/v1/__init__.py`:
       - Export api_router that includes pdf router

    3. Update `app/main.py`:
       - Include router: app.include_router(api_router, prefix="/api/v1")

    4. All endpoints:
       - Use StreamingResponse for file returns
       - Set proper Content-Disposition header for download
       - Handle errors with appropriate HTTP status codes

    Reference PDF-01 to PDF-07 for endpoint behaviors.
  </action>
  <verify>
    python -c "
from app.api.v1.pdf import router
print(f'PDF router has {len(router.routes)} routes')
" && grep -q "include_router" app/main.py
  </verify>
  <done>
    - POST /api/v1/pdf/merge endpoint exists
    - POST /api/v1/pdf/split endpoint exists with all modes
    - POST /api/v1/pdf/rotate endpoint exists
    - POST /api/v1/pdf/reorder endpoint exists
    - POST /api/v1/pdf/delete-pages endpoint exists
    - Router registered in main app
    - All endpoints return StreamingResponse
  </done>
</task>

<task type="auto">
  <name>Task 4: Add file upload handling and validation</name>
  <files>
    app/utils/file_utils.py
    app/services/pdf_service.py
  </files>
  <action>
    Create file handling utilities:

    1. Create `app/utils/file_utils.py`:
       - validate_pdf(file: UploadFile) -> BytesIO
         - Check content-type is application/pdf
         - Check file size against MAX_FILE_SIZE_MB
         - Read file into BytesIO
         - Return BytesIO for in-memory processing
       - generate_filename(operation: str, original_name: str) -> str
         - Generate sensible download filename
         - Format: "{original_base}_{operation}.pdf"
       - create_zip_archive(files: list[tuple[str, BytesIO]]) -> BytesIO
         - Create in-memory ZIP from list of (filename, BytesIO) tuples
         - Return ZIP as BytesIO

    2. Update pdf_service to use validation:
       - Import and use validate_pdf in all endpoints
       - Use generate_filename for download names

    3. Add size limits to config:
       - Update Settings with MAX_FILE_SIZE_MB usage

    Reference ARCH-06: File size limits prevent memory exhaustion.
  </action>
  <verify>
    python -c "
from app.utils.file_utils import validate_pdf, generate_filename, create_zip_archive
print('File utilities exist')
"
  </verify>
  <done>
    - validate_pdf checks content-type and size
    - validate_pdf returns BytesIO for in-memory processing
    - generate_filename creates sensible download names
    - create_zip_archive creates in-memory ZIP files
    - File size limits enforced
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Create test PDFs: Use any simple PDF files
2. Test merge: `curl -X POST -F "files=@test1.pdf" -F "files=@test2.pdf" http://localhost:8000/api/v1/pdf/merge -o merged.pdf`
3. Test split: `curl -X POST -F "file=@test.pdf" -F "mode=range" -F "start=1" -F "end=2" http://localhost:8000/api/v1/pdf/split -o split.zip`
4. Test rotate: `curl -X POST -F "file=@test.pdf" -F "pages=all" -F "degrees=90" http://localhost:8000/api/v1/pdf/rotate -o rotated.pdf`
5. Verify all operations work without creating disk files
</verification>

<success_criteria>
- User can merge multiple PDFs via API
- User can split PDF by range, every N pages, or specific pages
- User can rotate pages (all or specified)
- User can reorder pages
- User can delete pages
- All operations use in-memory BytesIO processing
- Requirements PDF-01 to PDF-07 implemented
</success_criteria>

<output>
After completion, create `.planning/phases/01-mvp-foundation/01-03-SUMMARY.md`
</output>
